#pragma once
// <Auto-Generated>
// This is here so CodeMaid doesn't reorganize this document
// </Auto-Generated>

#include "camera.cuh"
#include "hitable.cuh"
#include "hitable_list.cuh"
#include "material.cuh"
#include "objects/plane.cuh"
#include "objects/sphere.cuh"
#include "ray.cuh"
#include "render.cuh"
#include "render_datapoint.cuh"
#include <cuda.h>
#include <curand_kernel.h>
#include <device_launch_parameters.h>
#include <limits>
#include <random>
#include <shared/cuda_helpers.cuh>
#include <shared/random_helpers.cuh>
#include <shared/scoped_timer.cuh>
#include <shared/vecs/vec3.cuh>
#include <shared/vecs/vec8.cuh>
#include <time.h>
#include <vector>

/**
 *
 * Goto the botton for the definition of the cuda_renderer class
 *
 */

namespace ppt
{
namespace path_tracer
{
#define RM(row, col, w) row* w + col
#define CM(row, col, h) col* h + row

#define RM3(row, col, w) 3 * row* w + 3 * col
#define CM3(row, col, h) 3 * col* h + 3 * row


namespace cuda_methods
{


__device__ vec3 color(const ray& r, hitable** world, curandState* local_rand_state, float min_depth, float max_depth)
{
    ray cur_ray = r;
    vec3 cur_attenuation = vec3(1.0f, 1.0f, 1.0f);
    hit_record rec;

    for (int i = 0; i < 10; i++)
    {
        if (!(*world)->hit(cur_ray, min_depth, max_depth, rec))
        {
            break;
        }

        ray scattered;
        vec3 attenuation;
        if (rec.mat_ptr->scatter(cur_ray, rec, attenuation, scattered, local_rand_state))
        {
            cur_attenuation *= attenuation;
            cur_ray = scattered;
        }
    }

    vec3 unit_direction = unit_vector(cur_ray.direction());
    float t = 0.5f * (unit_direction.y() + 1.0f);
    vec3 c = vec3(1.0, 1.0, 1.0) * (1.0f - t) + vec3(0.5, 0.7, 1.0) * t;
    return c * cur_attenuation;
}

__global__ void
render_image(vec3* image_matrix, int max_x, int max_y, int samples, camera* cam, hitable** world, curandState* rand_state)
{
    int row = threadIdx.x + blockIdx.x * blockDim.x;
    int col = threadIdx.y + blockIdx.y * blockDim.y;
    if ((col >= max_x) || (row >= max_y))
        return;

    int pixel_index = RM(row, col, max_x);
    curandState local_rand_state = rand_state[pixel_index];

    vec3 pix = vec3(image_matrix[pixel_index].e);
    const camera local_camera(*cam);
    for (int s = 0; s < samples; s++)
    {
        float u = float(col + curand_normal(&local_rand_state)) / float(max_x);
        float v = float(max_y - row + curand_normal(&local_rand_state)) / float(max_y);
        ray r = local_camera.get_ray(u, v);
        pix += color(r, world, &local_rand_state, local_camera._min_depth, local_camera._max_depth);
    }

    rand_state[pixel_index] = local_rand_state;
    image_matrix[pixel_index] = pix;
}

__device__ hit_record depth_map(hitable** world, camera* cam, int col, int row, int max_x, int max_y)
{
    hit_record rec;
    float u = float(col) / float(max_x);
    float v = float(max_y - row) / float(max_y);
    const camera local_camera(*cam);

    ray r = local_camera.get_ray(u, v);
    (*world)->hit(r, local_camera._min_depth, local_camera._max_depth, rec);
    return rec;
}

__global__ void
post_process(vec3* image_matrix, vec8* out_image_matrix, hitable** world, camera* camera, int max_x, int max_y, int samples)
{
    int row = threadIdx.x + blockIdx.x * blockDim.x;
    int col = threadIdx.y + blockIdx.y * blockDim.y;
    if ((col >= max_x) || (row >= max_y))
        return;

    int pixel_index = RM(row, col, max_x);
    auto in_pixel = image_matrix[pixel_index];
    auto norm_rgb = (vec3(in_pixel.e) / float(samples)).v_sqrt();

    auto sample_precision = __logf(samples) / 16.0f; // 2^16=65536 is our (arbitrarily) choosen max number of samples
    auto hit = depth_map(world, camera, col, row, max_x, max_y);
    auto depth = sqrtf(fabs(hit.t)) / sqrtf(camera->_max_depth);

    out_image_matrix[pixel_index] =
        vec8(norm_rgb, sample_precision, depth, hit.normal[0], hit.normal[1], hit.normal[2]);
}


__global__ void render_init(int max_x, int max_y, int offset, curandState* rand_state)
{
    int row = threadIdx.x + blockIdx.x * blockDim.x;
    int col = threadIdx.y + blockIdx.y * blockDim.y;
    if ((col >= max_x) || (row >= max_y))
        return;

    int pixel_index = RM(row, col, max_x);
    // Each thread gets same seed, a different sequence number, no offset
    curand_init(row, col, offset, &rand_state[pixel_index]);
}

__global__ void reset_image(vec3* color_matrix, int max_x, int max_y)
{
    int row = threadIdx.x + blockIdx.x * blockDim.x;
    int col = threadIdx.y + blockIdx.y * blockDim.y;
    if ((col >= max_x) || (row >= max_y))
        return;

    int pixel_index = RM(row, col, max_x);
    color_matrix[pixel_index] = vec3(0, 0, 0);
}

__global__ void create_world(hitable** d_list, hitable** d_world, camera* d_camera, int hitables_size)
{
    if (threadIdx.x == 0 && blockIdx.x == 0)
    {
        d_list[0] = new plane(vec3(0, -0.5, 0), vec3(0, 1, 0), new lambertian(vec3(0.6, 0.8, 0.6)));
        d_list[1] = new sphere(vec3(0, 0, -1), 0.5, new lambertian(vec3(0.1, 0.2, 0.5)));
        d_list[2] = new sphere(vec3(1, 0, -1), 0.5, new metal(vec3(0.8, 0.6, 0.2), 0.0));
        d_list[3] = new sphere(vec3(-1, 0.0, -1), 0.5, new dielectric(1.5f));
        d_list[4] = new sphere(vec3(-1, 0.0, -1), -0.45, new dielectric(1.5f));

        *d_world = new hitable_list(d_list, hitables_size);
        *d_camera = camera_factory().make_16_9_camera();
    }
}

__global__ void create_random_world(hitable** d_list,
                                    hitable** d_world,
                                    camera* d_camera,
                                    int hitables_size,
                                    int reflection,
                                    int refraction,
                                    curandState* curand_state)
{
    if (threadIdx.x == 0 && blockIdx.x == 0)
    {
        auto local_rand = &curand_state[0];
        auto number_of_reflection = 0;
        auto number_of_refraction = 0;
        for (auto i = 0; i < hitables_size; i++)
        {
            if (i == 0)
            {
                d_list[i] = new plane(vec3(0, -3, 0),
                                      vec3(0, 1, 0),
                                      new lambertian(vec3(curand_uniform(local_rand),
                                                          curand_uniform(local_rand),
                                                          curand_uniform(local_rand))));
                continue;
            }

            material* mat;
            if (number_of_reflection < reflection)
            {
                mat = new metal(vec3(curand_uniform(local_rand), curand_uniform(local_rand), curand_uniform(local_rand)),
                                curand_uniform(local_rand));
                number_of_reflection++;
            }
            else if (number_of_refraction < refraction)
            {
                mat = new dielectric(0.001f + fabs(curand_uniform(local_rand) - 0.001f));
                number_of_refraction++;
            }
            else
            {
                mat = new lambertian(
                    vec3(curand_uniform(local_rand), curand_uniform(local_rand), curand_uniform(local_rand)));
            }
            d_list[i] = new sphere(vec3((curand_uniform(local_rand) - 0.5) * 14,
                                        (curand_uniform(local_rand) - 0.5) * 8,
                                        curand_uniform(local_rand) * -3 - 2),
                                   curand_uniform(local_rand) * curand_uniform(local_rand) * 1.5 + 0.3,
                                   mat);
        }

        *d_world = new hitable_list(d_list, hitables_size);
        *d_camera = camera_factory().make_16_9_camera();
    }
}

__global__ void free_world(hitable** d_world, camera* d_camera)
{
    delete d_world;
    delete d_camera;
}
} // namespace cuda_methods

class cuda_renderer
{
    private:
    curandState* d_rand_state;
    hitable** d_list;
    hitable** d_world;
    camera* d_camera;
    std::default_random_engine generator;

    public:
    int num_threads_x = 16;
    int num_threads_y = 16;
    dim3 blocks;
    dim3 threads;
    const size_t w;
    const size_t h;

    cuda_renderer(int w, int h)
      : blocks(h / num_threads_y + 1, w / num_threads_x + 1)
      , threads(num_threads_x, num_threads_y)
      , w(w)
      , h(h)
      , generator(std::default_random_engine())
    {
        const auto timer = shared::scoped_timer("cuda_renderer");

        int hitables_size = 5;
        checkCudaErrors(cudaMalloc((void**)&d_rand_state, w * h * sizeof(curandState)));
        checkCudaErrors(cudaMalloc((void**)&d_list, hitables_size * sizeof(hitable*)));
        checkCudaErrors(cudaMalloc((void**)&d_world, sizeof(hitable*)));
        checkCudaErrors(cudaMalloc((void**)&d_camera, sizeof(camera)));

        checkCudaErrors(cudaGetLastError());
        checkCudaErrors(cudaDeviceSynchronize());

        // init random
        cuda_methods::render_init<<<blocks, threads>>>(w, h, 0, d_rand_state);
        checkCudaErrors(cudaGetLastError());
        checkCudaErrors(cudaDeviceSynchronize());
        cuda_methods::create_world<<<1, 1>>>(d_list, d_world, d_camera, hitables_size);
        checkCudaErrors(cudaGetLastError());
        checkCudaErrors(cudaDeviceSynchronize());
    }

    ~cuda_renderer()
    {
        checkCudaErrors(cudaDeviceSynchronize());
        cuda_methods::free_world<<<1, 1>>>(d_world, d_camera);
        checkCudaErrors(cudaGetLastError());
    }

    public: // Methods
    render ray_trace(int samples)
    {
        const auto timer = shared::scoped_timer("ray_trace");

        auto ray_traced_image = render(w, h);
        auto* color_matrix = ray_traced_image.get_color_matrix();
        auto* image_matrix = ray_traced_image.get_image_matrix();

        cuda_methods::render_image<<<blocks, threads>>>(color_matrix, w, h, samples, d_camera, d_world, d_rand_state);
        checkCudaErrors(cudaGetLastError());
        checkCudaErrors(cudaDeviceSynchronize());
        cuda_methods::post_process<<<blocks, threads>>>(color_matrix, image_matrix, d_world, d_camera, w, h, samples);
        checkCudaErrors(cudaGetLastError());
        checkCudaErrors(cudaDeviceSynchronize());
        return ray_traced_image;
    }

    void update_world()
    {
        checkCudaErrors(cudaDeviceSynchronize());
        cuda_methods::free_world<<<1, 1>>>(d_world, d_camera);
        checkCudaErrors(cudaGetLastError());
        cuda_methods::create_random_world<<<1, 1>>>(d_list, d_world, d_camera, 13, 2, 2, d_rand_state);
        checkCudaErrors(cudaGetLastError());
    }

    std::vector<path_tracer::render_datapoint> ray_trace_datapoints(const int samples[4], size_t number_of_images)
    {
        const auto timer = shared::scoped_timer("ray_trace_datapoint");
        auto ray_traced_image = render(w, h);
        auto results = std::vector<path_tracer::render_datapoint>();
        results.reserve(number_of_images);
        for (auto i = 0; i < number_of_images; i++)
        {
            std::cout << "Rendering " << (i + 1) << "/" << number_of_images << std::endl;
            update_world();
            results.push_back(ray_trace_datapoint(samples, ray_traced_image));
            cuda_methods::reset_image<<<blocks, threads>>>(ray_traced_image.get_color_matrix(), w, h);
            checkCudaErrors(cudaDeviceSynchronize());
        }

        return results;
    }

    path_tracer::render_datapoint ray_trace_datapoint(const int samples[4])
    {
        const auto timer = shared::scoped_timer("ray_trace_datapoint");
        auto ray_traced_image = render(w, h);
        auto result = ray_trace_datapoint(samples, ray_traced_image);

        return result;
    }

    path_tracer::render_datapoint ray_trace_datapoint(const int samples[4], render& ray_traced_image)
    {
        auto result = path_tracer::render_datapoint(w, h);
        auto* color_matrix = ray_traced_image.get_color_matrix();
        auto* image_matrix = ray_traced_image.get_image_matrix();

        int sample_sum = 0;
        for (auto i = 0; i < 4; i++)
        {
            auto low = i == 3 ? samples[i] - sample_sum : samples[i];
            auto high = i == 3 ? low : low * 9;
            std::uniform_int_distribution<int> distribution(low, high);

            int sample = distribution(generator);
            sample_sum += sample;

            const auto timer_intern = shared::scoped_timer(" _samples: " + std::to_string(sample));

            cuda_methods::render_image<<<blocks, threads>>>(color_matrix, w, h, sample, d_camera, d_world, d_rand_state);
            checkCudaErrors(cudaGetLastError());
            checkCudaErrors(cudaDeviceSynchronize());

            cuda_methods::post_process<<<blocks, threads>>>(color_matrix, image_matrix, d_world, d_camera, w, h, sample_sum);
            checkCudaErrors(cudaGetLastError());
            checkCudaErrors(cudaDeviceSynchronize());

            result.set_result(ray_traced_image, i);
        }
        return result;
    }
};

} // namespace path_tracer
} // namespace ppt